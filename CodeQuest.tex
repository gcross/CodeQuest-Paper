%@+leo-ver=4-thin
%@+node:gcross.20090405101642.3:@thin CodeQuest.tex
%@@language latex

%@<< Prelude >>
%@+node:gcross.20090405101642.4:<< Prelude >>
\documentclass[twocolumn,showpacs,preprintnumbers,amsmath,amssymb,nofootinbib,pra,floatfix]{revtex4}

\usepackage{mathrsfs,amsthm,pseudocode}

\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{corolary}{Corolary}

\newenvironment{definition}[1][Definition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}

\newenvironment{example}[1][Example]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{remark}[1][Remark]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
%@-node:gcross.20090405101642.4:<< Prelude >>
%@nl

\begin{document}

%@+others
%@+node:gcross.20090513124712.1:Title Page
\title{CodeQuest}

\author{Gregory M. Crosswhite}
\affiliation{Department of Physics\\ University of Washington\\ Seattle, 98185}

\author{Dave Bacon}
\affiliation{Department of Computer Science \& Engineering \\ Department of Physics \\ University of Washington \\ Seattle, 98185}

%\pacs{03.67.-a}

\email{gcross@phys.washington.edu, dabacon@cs.washington.edu}


\maketitle

\newpage

\tableofcontents
%@-node:gcross.20090513124712.1:Title Page
%@+node:gcross.20090405101642.5:Introduction
In the field of quantum computing, there is a grand battle between the
forces of humankind, which seek to reliably store and manipulate
quantum information, and the forces of nature, which generally seek to
destroy it.  Although armies of experimentalists have made hereoic
efforts to build systems that shield quantum information from harm,
nature inevitably manages to get past these defences from time to time
and strike a blow.  This might seem to paint a grim outlook for the
possibility of building a quantum computer, but happily it turns out
to be the case that one can generally repair damage to quantum
information as long as one knows the exact form that the damage took,
and furthermore that one can build a `trap' --- that is to say, a
\emph{quantum code} --- that tricks nature into giving this
information up.

Now, the nature of codes is that they decouple the space in which our
computation lives from the space in which the physical information is
stored; that is to say, although we design our quantum circuit to
operate on some space of qubits $\mathscr{C}$, each of these qubits
does \emph{not} directly correspond to a physical qubit, but rather
there is some isomorphism that relates the entire space $\mathscr{C}$
to the space of physical qubits, $\mathscr{P}$.  To distinguish
between these two spaces, we shall call the space of qubits in whose
terms the computation is expressed the \emph{computational space}, and
the space of qubits which have physically been built the
\emph{physical space}.

Of course, merely building an isomorphism between these two spaces is
not enough to allow us to correct errors.  For one thing, we need to
add extra qubits to the computational space that contain a record of
the damage that we can read out; thus, we shall say that the full
computational space is $\mathscr{C}:=\mathscr{R}\times\mathscr{Q}$,
where the qubits that live in $\mathscr{R}$ have the role of keeping a
record of the errors that have been introduces, and the qubits that
live in $\mathscr{Q}$ are the qubits in whose terms our quantum
algorithm is expressed.  Since we are only performing measurements on
$\mathscr{R}$, we can effectively ignore all operators except, say,
the $Z$ measurement operator for each qubit; this set of commuting
operators allows us to completely measure the state of qubits in
$\mathscr{R}$.  In order to build the `trap' element into our system,
we need to ensure that whenever nature strikes at the physical space
$\mathscr{P}$, it is isomorphic to a strike on the computational space
that leaves a \emph{measureable} record in $\mathscr{R}$, which means
in particular that it is isomorphic to an operator that must
\emph{anti-commute} with the $Z$ operator (or whatever else we have
chosen to be our basis of measurement) of one of the qubits in
$\mathscr{R}$.  Note that although we speak of measuring the qubits in
$\mathscr{R}$, they of course cannot be measured directly, but instead
we take the measurement operator of interest in $\mathscr{R}$ and
measure the \emph{isomorphic} operator in the physical space
$\mathscr{P}$; this isomorphic operator is referred to as a
\emph{stabilizer}, and the full set of operators on $\mathscr{P}$
which are isomorphic to our chosen measurement operators on
$\mathscr{R}$ are referred to as the \emph{stabilizers} of the code.

Up to this point, the formalism we have described is known as
\emph{stabilizer codes} and its essential characteristic is the
forcing of every qubits in $\mathscr{R}$ to always have a definite
value in some basis by performing continuous measurement.  What if,
however, we relaxed this constraint and only continuously measured
some of the qubits in $\mathscr{R}$?  That is to say, what if we split
the qubits in $\mathscr{R}$ into two catagories: \emph{stabilizer
qubits} whose states we care about and force to always have a definite
value in some basis through continuous measurement, \emph{gauge
qubits} whose states we do not care about.  (The latter get their name
from the fact that they provide a `gauge' degree of freedom, i.e. a
degree of freedom that is irrelevent to us.)  Then we would have that
$\mathscr{R}=\mathscr{S}\times \mathscr{G}$, where $\mathscr{S}$ is
the space in which the stabilizer qubits live, and $\mathscr{G}$ is
the space in which the so-called gauge qubits live; such a scheme is
known as a \emph{subsystem code}.  In this case, we shall use the term
\emph{stabilizers} to denote the set of operators in $\mathscr{P}$
which are isomorphic to our chosen measurement operators of interest
in $\mathscr{S}$.

At first there might not seem to be an advantage to this approach,
since it essentially means adding qubits to our code that are
`wasted'; however, in practice this can actually make our code easier
to implement in a physical system.  The reason for this is that often
the measurement of stabilizers requires performing operations that
involve several qubits at once, which can be difficult or impossible
to implement\footnote{See, for example, the \emph{toric code} [ref],
which uses 4-qubit measurements.}  However, there are ways that by
adding additional qubits, one can instead use a set of, say, 2-qubit
operators whose simultaneous measurement results in an effective
measurement of all of the stabilizers so that the stabilizer qubits
are all collapsed to definite values in our chosen basis\footnote{For
examples of this, see the compass model code [ref].}.

What makes this approach powerful is that we no longer need our
measurements on the physical system to commute with each other, as
long as they all commute with the stabilizers, since then the fact
that they do not commute only affects the gauge qubits, which we do
not care about.  In fact, it is so powerful that any set of
measurements that are members of the Pauli group on the physical
qubits can be used to implement a subsystem code, and in fact we can
compute the code that it implements, as we shall prove in this paper;
of course, the resulting code might not be useful --- since among
other possibilities, it might be that it has no room for encoding the
quantum information that we want to store --- but it definitely
exists.  This fact invites an approach to finding useful subsystem
codes that is in many ways opposite to the approach commonly taken:
rather than coming up with codes and then trying to figure out how
they might be physically implemented, why not start with a class of
physical implementations and search within it for useful subsystem
codes?  This is the approach that we explore in this paper.

In the first section, we shall formally prove that every set of
measurements that are members of the Pauli group acting on the system
give rise to a subsystem code, and we shall in the process present
algorithms for computing this code (or at least, for computing one
such code, since it is not unique) and its distance.  In the second
section, we shall present numerical results obtained by applying a
code implementing this algorithm to explore systems built using
lattices that take the form of te 11 regular tilings.  In the third
section, we shall present an algorithm for seaching over all of the
systems that can be implemented by using arbtitrary Ising interactons
with the structure of a graph, and then we shall present the results
that we have obtained from our searches.
%@-node:gcross.20090405101642.5:Introduction
%@+node:gcross.20090423002455.2:Algorithm
\section{Algorithm}

%@+node:gcross.20090511123440.2:Overview
\subsection{Overview}

\label{overview}

Although conceptually a subsystem code is an isomorphism $T$ such that  $\mathscr{P}\approx^T \mathscr{S}\times\mathscr{G}\times\mathscr{Q}$ --- that is, an isomorphism between the \emph{physical} space of qubits and the \emph{computational} space of qubits in whose terms our computation is actually expressed, we do not need to actually construct this isomorphism in order to be able to use the code.  Since all of our work will be done on the physical system anyway, it suffices to know the operators in the physical space $\mathscr{P}$ that are isomorphic to the qubit measurement operators of interest in the computational space $\mathscr{S}\times\mathscr{G}\times\mathscr{Q}$, and it is exactly the operators on $\mathscr{P}$ that the algorithm we present shall compute\footnote{If one really wanted to, one could explicitly construct the isomorphism $\mathscr{T}$ from these operators by computing the unitary operator which simultaneously diagonalizes a the maximal subset of commuting measurements from this set of operators on $\mathscr{P}$, but in practice this is not particularly useful.}.

When one wants to define a qubit in terms of its measurement operators, it suffices to define two operators that anti-commute with each other but which commute with all of the others measurement operators that have been defined, since this gives us the $X$ and $Z$ measurements on the qubit which are sufficient to generate the full $Pauli$ group (minus phases).  Since working with such pairs of operators shall be a common theme in our algorithm, we shall create the following definition in order to simplify the language used to describe them.

\begin{definition} A pair of operators is a \emph{conjugal pair in relation to the set} $\tilde X$ when each of the operators in the pair commutes with every operator in $\tilde X$ except for its \emph{conjugal partner} --- that is, the other operator in the conjugal pair --- should its conjugal partner be a member of $\tilde X$.
\end{definition}

Note that we have explicitly not required that the operators in the conjugal pair be members of $\tilde X$ in order to be a conjugal pair in relation to it.  However, should both operators be members of $\tilde X$, then neither operator can belong to a different conjugal pair with respect to $\tilde X$, since in that case there would be an operator in $\tilde X$ (namely, its original conjugal partner) with which it anti-commutes that was not its conjugal partner in the new pair, leading to a contradiction.

We now formally define the problem solved by our algorithm.  Assume that we have been given a list of operators $\tilde O :=\{O_1,\dots,O_n\}\in \mathcal{P}_n$ --- that is, a list of tensor products of $N$ Pauli operators which act on a Hilbert space of $N$ physical qubits, $\mathscr{H}:=\mathbb{C}^{2N}$.  This list of operators, $\tilde O$, generates a subgroup $\mathcal{O}$ of $\mathcal{P}_n$.  In section \ref{stabilizers-and-gauge-qubits}, we shall prove one can always find sets of operators $\tilde S$ and $\tilde G$ such that the following properties hold:
\begin{itemize}
\item each of the operators in $\tilde S \cup \tilde G$ is
  independent from the rest --- i.e., no operator in this (unioned) set can
  be written as a product of other operators in the set
\item all of the operators in $\tilde S$ commute with each other and
  also all of the operators in $\tilde G$;
\item each operator in $\tilde G$ is a member of a conjugal pair in relation to $\tilde S \cup \tilde G$;
\item the subgroup generated by $\tilde S \cup \tilde G$ is exactly
  the subgroup $\mathcal{O}$ generated by $\tilde O$.
\end{itemize}
The proof that we give in \ref{stabilizers-and-gauge-qubits} will be
constructive, and hence will also serve to explain our algorithm for
computing $\tilde S$ and $\tilde G$, which is the first step in
computing the subsystem code.

Once the stabilizer and gauge qubits are known, in order to complete the subsystem code it remains to compute the `logical' qubits. Formally, this is a list of operators $\tilde L$ which satisfy the following properties
\begin{itemize}
\item all of the operators in $\tilde S \cup \tilde G \cup \tilde L$
  are independent;
\item each operator in $\tilde L$ is a member of a conjugal pair with respect to $\tilde S \cup \tilde G \cup \tilde L$;
\item the subgroup generated by $\tilde S \cup \tilde G \cup \tilde L$ is exactly the subgroup of operators in $\mathcal{P}_n$ which all commute with every operator in $\tilde S$  (and hence with the entire subgroup generated by $\tilde S$)\footnote{Note that this requirement ensures that taking any maximal subset of commuting operators from $\tilde S \cup \tilde G \cup \tilde L$ and then writing down the unitary transformation which simultaneously diagonalizes all of these operators gives us an isomorphism between the physical space $\mathscr{P}$ and the computational space $\mathscr{S}\times\mathscr{G}\times\mathscr{L}$.  That is, in a metter of speaking it ensures that every physical qubits has been used in our code.  Note, however, that this does \emph{not} mean that the operators in $\tilde S \cup \tilde G \cup \tilde L$ generate the full Pauli group $\mathcal{P}_n$, since the full Pauli group includes operators which anti-commute with operators in $\tilde S$, and by construction no such operators can be made from a product of operators in $\tilde S \cup \tilde G \cup \tilde L$.}.
\end{itemize}
In section \ref{logical-qubits} we shall prove that a list of operators $\tilde L$ can be constructed with these properties, which is the final step in computing the subsystem code.

Now that the full subsystem code has been computed, it remains to determine how well it protects the quantum information stored in the logical qubits.  Recall that each \emph{conjugal pair} fully defines the measurement operators on a single logical qubit of the system.  The distance of that qubit is the minimum weight operator that acts non-trivially on the qubit --- that is, which anti-commutes with one of the operator in the conjugal pair --- but which commutes with all of the operators in $\tilde S$ and hence cannot be detected.  If there are $N$ qubits defined by the conjugal pairs in $\tilde L$, then each of these has a distance which we shall name $d_1,\dots,d_N$, where $d_1\le d_2 \le \dots \le d_N$.  Now, the choice of the operators in $\tilde L$ which satisfy the properties listed in the previous paragraph is not unique, so different choices can have different values for the distances.  The choice with the \emph{optimal distances} is the choice with distances $d_1\le \dots \le d_N$ such that given any choicr with distances $d_1'\le \dots \le d_N'$, we have that $d_i' \le d_i$ for $i\in 1\dots N$.  In section \ref{optimal-distances} we shall prove that starting with any subsystem code we can compute the choice of logical operators with that code which has the optimal distances.  This completes our algorithm.
%@-node:gcross.20090511123440.2:Overview
%@+node:gcross.20090423002455.3:Stabilizers and gauge qubits
\subsection{Stabilizers and gauge qubits}

\label{stabilizers-and-gauge-qubits}

%@<< Theorems >>
%@+node:gcross.20090511123440.4:<< Theorems >>
\subsubsection{Theory}

\begin{theorem} \label{theorem-SG} Suppose that we are given a list of operators $\bar O$.  Then there exist sets of operators $\tilde S$ and $\tilde G$ such that the following properties hold:
\begin{enumerate}
\item each of the operators in $\tilde S \cup \tilde G$ is
  independent from the rest --- i.e., no operator in this (unioned) set can
  be written as a product of other operators in the set
\item \label{theorem-all-commute-SG-prop} all of the operators in $\tilde S$ commute with each other and
  also all of the operators in $\tilde G$;
\item \label{theorem-conjugal-pairs-SG-prop} each operator in $\tilde G$ is a member of a conjugal pair in relation to $\tilde S \cup \tilde G$;
\item \label{theorem-complete-SG-prop} the Pauli subgroup generated by $\tilde S \cup \tilde G$ is exactly
  the subgroup generated by $\bar O$.
\end{enumerate}
\end{theorem}

\begin{remark}
Before embarking on the proof of this thereom, we will first prove some useful propositions.  The first will show that we can incrementally build up \emph{lists} (as opposed to sets) $\bar G$ and $\bar S$ that satisfy properties \ref{theorem-all-commute-SG-prop} and \ref{theorem-conjugal-pairs-SG-prop} while removing operators from the given list of operators $\bar O$.
\end{remark}

\begin{proposition} \label{proposition-SG} Suppose that we are given lists of operators $\bar S$, $\bar G$, and non-empty $\bar O$ that satisfy the following properties:
\begin{enumerate}
\item all of the operators in $\bar S$ commute with each other and also all of the operators in $\bar G$; \label{stabs-commute-with-G}
\item each operator in $\bar G$ is a member of a \emph{conjugal pair} (defined in section \ref{overview}) in relation to $\bar S \cup \bar G \cup \bar O$. \label{conjugal-pairs-commute-with-SAG}
\end{enumerate}
Then there exists lists of operators $\bar S'$, $\bar G'$, and $\bar O'$ which also satisfy the above properties (substituting the primed label in the places of the unprimed label) such that the subgroups generated by respectively $\bar S\cup \bar G\cup \bar O$ and $\bar S'\cup \bar G'\cup \bar O'$ are equal, and furthermore $\bar O'$ is strictly shorter in length than $\bar O$.
\end{proposition}

\begin{remark}
Note that at this point, we have deliberately \emph{not} constrained the operators in $\bar S$ to be independent, although the operators in $\bar G$ are necessarily independent since they are all members of conjugal pairs.  Furthermore, since we are using \emph{lists} of operators rather than \emph{sets}, it is possible for there to be duplicate operators in $\bar S$ or $\bar O$ --- though property \ref{conjugal-pairs-commute-with-SAG} prevents the existence of duplicates inside $\bar G$.
\end{remark}

\begin{proof}
Since by assumption $\bar O$ is non-empty, we may take any operator $O\in \bar O$ and let $\bar O_{\slash O}:=\bar O\slash O$.  Note that by property \ref{conjugal-pairs-commute-with-SAG} we know that $O$ commutes with all of the operators in $\bar G$.  Given this, there are two cases to consider:
\begin{enumerate}
\item when $O$ commutes with all of the operators in $\bar S$;
\item when there is some operator $S\in\bar S$ with which it anti-commutes.
\end{enumerate}

\begin{description}
\item[Case 1]
Let $\bar S':= \bar S \cup \{O\}$, $\bar G' := G$, and $\bar O' := \bar O_{\slash O}$.  $\bar S'$ continues to satisfy property \ref{stabs-commute-with-G} because $O$ commutes with all of the operators in $\bar S$ and $\bar G$.  Since $\bar G'$ is the same as $\bar G$, it continues to satisfy property \ref{conjugal-pairs-commute-with-SAG}.  Furthermore, since $\bar S\cup \bar G \cup \bar O=\bar S' \cup \bar G' \cup \bar O'$, we have that $\bar S' \cup \bar G' \cup \bar O'$ continues to generate the subgroup $\mathcal{O}$.  Finally, because by construction $\bar O'$ has one fewer element than $\bar O$, we have that $|\bar O'|=|\bar O|-1$, and so we are done.
\item[Case 2]
Let $\bar S_{\slash S}:=\bar S\slash S$, and $\bar G' := \bar G \cup \{S,O\}$.  There are three things that we need to show:  First, that we can define $\bar S'$ to satisfy property \ref{stabs-commute-with-G}.  Second, that we can define $\bar O'$ to satisfy property \ref{conjugal-pairs-commute-with-SAG}.  Finally, that we have $|\bar O'|=|\bar O|-1$, and  $\bar S' \cup \bar G' \cup \bar O'$ continue to generate the subgroup $\mathcal{O}$.

Let $\bar S' := [f(A) | A \in \bar S_{\slash S}]$ where $$f(A) :=
\begin{cases}
A & A \text{ and } O \text{ \emph{commute} }\\
A\cdot S  & A \text{ and } O \text{ \emph{anti-commute} }. \\
\end{cases}
$$
We now need to show that $\bar S'$ satisfies property \ref{stabs-commute-with-G}.  First, all of the operators in $\bar S'$ continue to commute with each other since they are all products of operators in the original list $\bar S$.  Furthermore, by the same argument we immediately conclude that all of the operators in $\bar S'$ continue to commute with all of the operators in $\bar G'$, except for possibly $O$ which is the only operator in $\bar G'$ not in $\bar G$ or $\bar S$.  Finally, we observe that for each element $A\in \bar S_{\slash S}$, we have that $f(A)$ commutes with $O$, since if $A$ anti-commutes with $O$ then $f(A)=A\cdot S$ which \emph{does} commute with $O$ since $O$ anti-commutes with $S$;  thus, since all of the elements in $\bar S_{\slash S}$ were run through the function $f$ to form $\bar S'$, we conclude that they all commute with $O$ as well, and hence with all of the operators in $\bar G'$.

Now let $\bar O' := [(g\circ f)(A) | A \in \bar O_{\slash O}]$ where $$g(A) :=
\begin{cases}
A & A \text{ and } S \text{ \emph{commute} }\\
A\cdot O  & A \text{ and } S \text{ \emph{anti-commute} }. \\
\end{cases}
$$
We now need to show that $\bar G'$ satisfies property \ref{conjugal-pairs-commute-with-SAG}.  Since $S$ and $O$ anti-commute with each other and commute with all of the operators in $\bar G'$ (as by property \ref{conjugal-pairs-commute-with-SAG} they commute with all of the operators in $\bar G$, and $\bar G':=\bar G\cup\{S,O\}$), and by the previous paragraph we showed that they commute with all of the operators in $\bar S'$, it remains only to show that they also commute with all of the operators in $O'$.  To do this, we observe that $(g\circ f)(A)$ commute with both $S$ and $O$ for every operator $A\in\bar O'$, since if $A$ anti-commutes with either or both of respectively $S$ and $O$ then it is multiplied by respectively $O$ and/or $S$ which forms a new operator that commutes with both.  Since all of the operators in $\bar O_{\slash O}$  were run through $g\circ f$ to form $\bar O$, we conclude that all of the operators in $\bar O'$ commute with all of the operators in $\bar G'$, and hence property \ref{conjugal-pairs-commute-with-SAG} is satisfied.

It is obvious $\bar O'$ is shorter in length than $\bar O$ due to the removal of an element from $\bar O$, so it remains only to show that $\bar S' \cup \bar G' \cup \bar O'$ continues to generate the subgroup $\mathcal{O}$.  To do this, note that any operator in $\bar S' \cup \bar G' \cup \bar O'$ was formed by products of operators in $\bar S \cup \bar G \cup \bar O$ with $S$ and/or $O$, and since $S$ and $O$ are their own inverse we can conversely obtain any operator in $\bar S \cup \bar G \cup \bar O$ from products of operator in $\bar S' \cup \bar G' \cup \bar O'$ and $S$ and/or $G$.  Since $S$ and $G$ are in both $\bar S \cup \bar G \cup \bar O$ and $\bar S' \cup \bar G' \cup \bar O'$, this means that any operator in one list can be written as a product of members of the other list, and so both lists of operators generate the same group, namely $\mathcal{O}$.
\end{description}
\end{proof}

\begin{corolary}
\label{corolary-SG}
Suppose that we are given a list of operators $\bar O$.  Then there exists a list of operators $\bar S$ and a set of independent operators $\tilde G$ satisfying the properties \ref{theorem-complete-SG-prop}, \ref{theorem-conjugal-pairs-SG-prop} and \ref{theorem-all-commute-SG-prop} that were listed in Theorem \ref{theorem-SG}.
\end{corolary}

\begin{proof}
Let $\bar O_0:=\bar O$, $\bar S_0:=[]$, and $\bar G_0:=[]$.  If $\bar O$ is the empty list then we are done.  Otherwise, we can apply Proposition \ref{proposition-SG} by setting $\bar O := O_0$, $\bar S:=\bar S_0$, and $\bar G := \bar G_0$ to conclude that there exist lists $\bar O_1:=\bar O'$, $\bar S_1:=$, and $\bar G_1:=\bar G'$ which satisfy the properties listed in the proposition, with $\bar O_1$ strictly shorter in length than $\bar O_0$.  If $\bar O_1$ is not empty, then we can apply the proposition again to obtain lists $\bar O_2$, $\bar S_2$, and $\bar G_2$ with the same properties and with $\bar O_2$ shorter than $\bar O_1$, and so on.  By repeating this procedure, we eventually obtain lists $\bar O_n$, $\bar S_n=:\bar S$, and $\bar G_n=:\bar G$ such that $\bar O_n$ is empty.  This means that the operators in $\bar S \cup \bar G$ generate the same group as those in $\bar O_0\equiv \bar O$, and so property \ref{theorem-complete-SG-prop} is satisfied.  Furthermore, the fact that properties \ref{theorem-conjugal-pairs-SG-prop} and \ref{theorem-all-commute-SG-prop} are satisfied comes directly from Proposition \ref{proposition-SG}.  Finally, due to property \ref{theorem-conjugal-pairs-SG-prop}, we observe that the operators in $\bar G$ must all be independent --- that is, if the operators were not independent so that say $O=O_1\cdot O_2\cdots O_n$ with $O,O_1,\dots,O_n\in\bar G$, then this would mean that the operator which anti-commute with $O_1$ would also anti-commute with $O$, and so neither $O$ nor $O_1$ could belong to a conjugal pair.  Thus, in particular there are no duplicates in $\bar G$, and so it is exactly equivalent to a set $\tilde G:=\bar G$ of independent operators.
\end{proof}

\begin{remark}
A consequence of not requiring independence of the operators in $\bar O$ is that the operators $\bar S$ given by Corolary \ref{corolary-SG} are not necessarily independent.  Happily, since all of these operators can be expressed as tensor products of Pauli operators, we can construct a set of independent operators by performing an analogue of Gaussian elimination.  There are two options that one has for doing this:  the `block' representation, in which elimination proceeds by eliminating both the $X$ and $Z$ operators in each physical qubits before moving to the next, or the `split' representation, in which elimination first clears out the $X$ operators from all of the physical qubits before starting to clear the $Z$ operators.  Although only one of these options is strictly necessary for the proof of \ref{theorem-SG}, we shall prove that both strategies work since each has an advantage in different circumstances.
\end{remark}

\begin{proposition}
Suppose that we have been given lists of Pauli operators $\bar I$ and $\bar D$ acting on $N$ qubits as well as an integer $0\le k\le N$ such that for all integers $1 \le i \le k$, the following properties hold:
\begin{enumerate}
\item in each ($N-$qubit tensor product) operator of $\bar D$, the single-qubit operator acting on qubit $i$ is the identity;
\item there is at most one operator in $\bar I$ for which the single-qubit operator acting on qubit $i$ is $X$;
\item there is at most one operator in $\bar I$ for which the single-qubit operator acting on qubit $i$ is $Z$.
\end{enumerate}
Then there exist lists $\bar I'$ and $bar D'$ and an integer $k+1$ such that the above properties also hold.
\end{proposition}

\begin{corolary}
Suppose that we have been given lists of Pauli operators $\bar D$ and $\bar I$ such that the operators in $\bar I$ are independent and $\bar D \cup \bar I$ generate some Pauli subgroup $\mathcal{S}$.  Then there exists lists of operators $\bar D'$ and $\bar I'$ such that $|\bar D'|<|\bar D|$, the operators in $\bar I'$ are independent, and $\bar D' \cup \bar I'$ also generates $\mathcal{S}$.
\end{corolary}

\begin{proof}
\end{proof}
%@-node:gcross.20090511123440.4:<< Theorems >>
%@nl

%@<< Pseudo-code >>
%@+node:gcross.20090511123440.5:<< Pseudo-code >>
\subsubsection{Psuedo-code}

The following is pseudo-code which explicitly implements the algorithm given in the theorem.  Although set notation is used, the objects used are understood to be lists, which means that they might contain duplicate elements.

\begin{pseudocode}{ComputeStabilizersAndGaugeQubits}{O}
S \GETS \text{empty list of operators }\\
G \GETS \text{empty list of pairs of operators}
\end{pseudocode}
%@-node:gcross.20090511123440.5:<< Pseudo-code >>
%@nl
%@-node:gcross.20090423002455.3:Stabilizers and gauge qubits
%@+node:gcross.20090427140200.2:Logical qubits
\subsection{Logical qubits}

\label{logical-qubits}
%@-node:gcross.20090427140200.2:Logical qubits
%@+node:gcross.20090511123440.3:Optimal distances
\subsection{Optimal distances}

\label{optimal-distances}
%@-node:gcross.20090511123440.3:Optimal distances
%@-node:gcross.20090423002455.2:Algorithm
%@-others

\end{document}
%@nonl
%@-node:gcross.20090405101642.3:@thin CodeQuest.tex
%@-leo
